function demoEfficiency()
%% this script compare efficiency of different ways of computing Jacobian
    caseSphereJacobian(100);
end

%% caseSphereJacobian compute Jacobian matrix of geodesic equations on sphere
%  N is the number of nodes
function caseSphereJacobian(N)
    x0 = [pi/2;pi/3]; xT = [3*pi/2;-pi/3];
    dim = length(x0);
    
    maxIter = 3;
    diff = zeros(maxIter,5);
    res = zeros(maxIter,1);
    tokeiNT = zeros(1, maxIter);
    tokei = zeros(6,maxIter);
    Extra.x0 = x0; Extra.xT = xT; Extra.N = N; Extra.dim = dim;
    Extra.JPIs = [];
    u = generateInitialValue(x0,xT,N);
    
    for k = 1:maxIter
        
        % finite difference
        profile -memory on
        [ffd, Jfd] = GeodesicEquationsOnSphereWithFD(u,Extra);
        profreport
        profsave(profile('info'),sprintf('SphereWithFD\\n_%d',N))

        % forward mode
        profile -memory on
        [ffm, Jfm] = GeodesicEquationsOnSphereWithForwardModeAD(u,Extra);
        profreport
        profsave(profile('info'),sprintf('SphereWithFM\\n_%d',N))
        
        % reverse mode
        profile -memory on
        [frm, Jrm] = GeodesicEquationsOnSphereWithReverseModeAD(u,Extra);
        profreport
        profsave(profile('info'),sprintf('SphereWithRM\\n_%d',N))
        
        % bi-coloring sparse mode
        profile -memory on
        [fsp, Jsp, Extra.JPI] = GeodesicEquationsOnSphereWithSparseAD(u, Extra);
        profreport
        profsave(profile('info'),sprintf('SphereWithSAD\\n_%d',N))
        
        % template mode
        profile -memory on
        [ftp, Jtp] = GeodesicEquationsOnSphereWithTemplate(u, Extra);
        profreport
        profsave(profile('info'),sprintf('SphereWithSTP\\n_%d',N))
        
        % sparse template mode
        profile -memory on
        [fstp, Jstp] = GeodesicEquationsOnSphereWithSparseTemplate(u, Extra);
        profreport
        profsave(profile('info'),sprintf('SphereWithFD\\n_%d',N))
        
        
        diff(k,1) = max(max(Jfd-Jfm));
        diff(k,2) = max(max(Jfd-Jrm));
        diff(k,3) = max(max(Jfd-Jsp));
        diff(k,4) = max(max(Jfd-Jtp));
        diff(k,5) = max(max(Jfd-Jstp));
        res(k) = norm(ffd);
        assert( 0 == norm(ffd-ffm) )
        assert( 0 == norm(ffd-frm) )
        assert( 0 == norm(ffd-fsp) )
        assert( 0 == norm(ffd-ftp) )
        assert( 0 == norm(ffd-fstp) )
        % Newton step
        tic;
        u = u - Jfd\ffd;
        tokeiNT(k) = toc;
    end
    figure; subplot(6,1,1)
    plot(diff(:,1));  title('difference between FD and Forward Mode')
    subplot(6,1,2)
    plot(diff(:,2));  title('difference between FD and Reverse Mode')
    subplot(6,1,3);
    plot(diff(:,3));  title('difference between FD and Bi-Coloring')
    subplot(6,1,4);
    plot(diff(:,4));  title('difference between FD and Template Mode')
    subplot(6,1,5);
    plot(diff(:,5));  title('difference between FD and Sparse Template Mode')
    subplot(6,1,6);
    plot(res);        title('residual v.s. num. of newton steps');
    
   % tokei
    tokeiNT
end

function [f, J] = GeodesicEquationsOnSphereWithFD(u, Extra)
    M = size(u,1);
    J = zeros(M);
    F = @(x) GeodesicEquationsOnSphere(x,Extra);
    f = F(u);
    for k = 1:M
        xp = u; xp(k) = xp(k) + 1e-6;
        J(:,k) = 1e6*(F(xp) - f);
    end
end

function [f, J] = GeodesicEquationsOnSphereWithReverseModeAD(u, Extra)
    M = size(u,1);
    AD_fun = ADfun(@GeodesicEquationsOnSphere, M);
    options = setopt('revprod', eye(M));
    [f, J] = feval(AD_fun, u, Extra, options);
    J = J';
end

function [f, J] = GeodesicEquationsOnSphereWithForwardModeAD(u, Extra)
    M = size(u,1);
    AD_fun = ADfun(@GeodesicEquationsOnSphere, M);
    options = setopt('forwprod', eye(M));
    [f, J] = feval(AD_fun, u, Extra, options);
end

function [f, J, JPI] = GeodesicEquationsOnSphereWithSparseAD(u, Extra)
    M = size(u,1);
    if( isempty(Extra) || ~isfield(Extra,'JPI') )
        [JPI, ~] = getjpi(@GeodesicEquationsOnSphere, M, M, Extra, 'd');
    else
        JPI = Extra.JPI;
    end
    [f, J] = evalj(@GeodesicEquationsOnSphere, u, Extra, M, JPI);
end

function u0 = generateInitialValue(x0,xT,N)
    dim = size(x0,1);
    V = repmat( (xT - x0)/(N+1), N, 1 );
    steps = reshape(repmat(1:N, dim, 1), [], 1);
    u0 = repmat(x0, N, 1) + V.*steps;
end